<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Abstract Animation</title>
    <style>
        /* Basic CSS to make the animation fullscreen and remove scrollbars */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111; /* Dark background */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- The canvas element is where the 3D scene will be rendered -->
    <canvas id="3d-canvas"></canvas>

    <!-- Import Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Import OrbitControls for mouse/touch interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // === SCENE SETUP ===
        // A scene is the container for all your 3D objects, lights, and cameras.
        const scene = new THREE.Scene();

        // A camera determines what we see. PerspectiveCamera mimics the human eye.
        // Arguments: Field of View, Aspect Ratio, Near Clipping Plane, Far Clipping Plane
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5; // Move the camera back so we can see the objects

        // The renderer is responsible for drawing the scene onto the canvas.
        const canvas = document.getElementById('3d-canvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true // Makes the edges of objects smoother
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Improves quality on high-res screens
        
        // === LIGHTING ===
        // Lighting is crucial for making objects visible and giving them depth.
        
        // Ambient light illuminates all objects in the scene equally from all directions.
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Directional light comes from a specific direction, like the sun. It creates shadows and highlights.
        const directionalLight = new THREE.DirectionalLight(0x00ffcc, 1);
        directionalLight.position.set(5, 5, 5); // Position the light
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xff00ff, 1.5);
        pointLight.position.set(-5, -5, 2);
        scene.add(pointLight);


        // === OBJECTS ===
        // We'll create some geometric shapes (meshes). A mesh is made of a geometry (the shape) and a material (the surface).

        // Geometry 1: A TorusKnot (a complex, knotted shape)
        const torusKnotGeometry = new THREE.TorusKnotGeometry(1, 0.3, 100, 16);
        // Material 1: MeshStandardMaterial is a physically based material that reacts realistically to light.
        const torusKnotMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8A2BE2, // A nice purple
            metalness: 0.7,   // How metallic it is (0-1)
            roughness: 0.2    // How rough the surface is (0-1)
        });
        const torusKnot = new THREE.Mesh(torusKnotGeometry, torusKnotMaterial);
        torusKnot.position.x = -3;
        scene.add(torusKnot);

        // Geometry 2: An Icosahedron (a 20-sided shape)
        const icosahedronGeometry = new THREE.IcosahedronGeometry(0.8);
        const icosahedronMaterial = new THREE.MeshStandardMaterial({
            color: 0x049ef4,
            metalness: 0.5,
            roughness: 0.4
        });
        const icosahedron = new THREE.Mesh(icosahedronGeometry, icosahedronMaterial);
        icosahedron.position.x = 3;
        scene.add(icosahedron);
        
        // Geometry 3: A smaller sphere
        const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const sphereMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.9,
            roughness: 0.1
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.y = 2;
        scene.add(sphere);


        // === CONTROLS ===
        // OrbitControls allow the user to rotate, pan, and zoom the camera with a mouse or touch.
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Adds a smooth "inertia" effect to the controls
        controls.autoRotate = true; // Makes the scene slowly rotate on its own
        controls.autoRotateSpeed = 0.5;

        // === ANIMATION LOOP ===
        // This function is called on every frame to update the scene and render it.
        const clock = new THREE.Clock(); // A clock to keep track of time for smooth animation

        const animate = () => {
            // Get the elapsed time since the clock started
            const elapsedTime = clock.getElapsedTime();

            // Animate the objects
            // We use sine and cosine functions for smooth, looping movements
            torusKnot.rotation.y = 0.5 * elapsedTime;
            torusKnot.rotation.x = 0.3 * elapsedTime;
            
            icosahedron.rotation.y = -0.4 * elapsedTime;
            icosahedron.rotation.x = -0.2 * elapsedTime;
            
            // Make the sphere float up and down
            sphere.position.y = 2 + Math.sin(elapsedTime * 1.5) * 0.5;

            // Update the controls for damping effect
            controls.update();

            // Render the scene from the perspective of the camera
            renderer.render(scene, camera);

            // Request the next frame, creating an infinite loop
            window.requestAnimationFrame(animate);
        };

        // Start the animation loop
        animate();

        // === RESPONSIVENESS ===
        // This function handles window resizing to keep the animation looking correct.
        window.addEventListener('resize', () => {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });
    </script>
</body>
</html>
